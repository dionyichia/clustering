#ifndef SINGLE_LINKAGE_HPP
#define SINGLE_LINKAGE_HPP

#include <vector>
#include <iostream>
#include <map>
#include <set>
#include "kd_tree/include/types.hpp"  // Include for Edge definition

enum class clusterMethod{
    EOM,
    Leaf
};

struct CondensedNode {
    int parent;
    int child;
    float lambda_val;
    int cluster_size;
    
    CondensedNode(int p, int c, float l, int s) : parent(p), child(c), lambda_val(l), cluster_size(s) {}
};

struct ClusterStability {
    float stability;
    std::vector<int> children;
    int cluster_size;
    bool is_cluster;
    
    ClusterStability() : stability(0.0f), cluster_size(0), is_cluster(true) {}
};

std::vector<int> bfs_from_node(int start_node, const std::vector<int>& left_child, 
                               const std::vector<int>& right_child, int n_samples);

std::vector<CondensedNode> condense_tree(const std::vector<int>& left_child,
                                        const std::vector<int>& right_child,
                                        const std::vector<float>& birth_lambda,
                                        const std::vector<float>& death_lambda,
                                        const std::vector<int>& sz,
                                        int n_samples,
                                        int root_node,
                                        int min_cluster_size = 10);

std::map<int, ClusterStability> calculate_cluster_stability(
    const std::vector<CondensedNode>& condensed_tree);

std::vector<int> bfs_descendants(int cluster_id, 
                                const std::map<int, ClusterStability>& cluster_stability);

std::set<int> excess_of_mass_selection(std::map<int, ClusterStability>& cluster_stability,
                                      int max_cluster_size = INT_MAX);

std::vector<std::vector<int>> extract_clusters_eom(const std::vector<CondensedNode>& condensed_tree, 
                                                  int n_samples, 
                                                  int max_cluster_size = INT_MAX);

std::vector<std::vector<int>> do_labelling_with_clusters(
    const std::vector<CondensedNode>& condensed_tree,
    const std::set<int>& selected_clusters,
    int n_samples);

// Struct for Cluster Output Comparison 
struct ClusterMetrics {
    double adjusted_rand_index;
    double normalized_mutual_info;
    double homogeneity;
    double completeness;
    double v_measure;
    double accuracy;  // Best matching accuracy
    int total_points;
    int num_predicted_clusters;
    int num_true_clusters;
    int noise_points;
};

// Function to perform single linkage clustering
std::vector<std::vector<int>> single_linkage_clustering(
    const std::vector<Edge>& mst_edges,
    int N_pts,
    int min_cluster_size = 2,
    clusterMethod clusterMethod = clusterMethod::EOM
);

__global__ void finalize_stability_kernel(
    const int* parent,
    const int* sz,
    const float* birth_lambda,
    const float* death_lambda,
    float* stability,
    int num_clusters,
    float lambda_max,
    float lambda_min,
    int num_connected_components
);

void parallel_finalize_stability(
    std::vector<int>& parent,
    std::vector<int>& sz,
    std::vector<float>& birth_lambda,
    std::vector<float>& death_lambda,
    std::vector<float>& stability,
    float lambda_max,
    float lambda_min,
    int num_connected_components,
    int next_cluster_id
);

const char* clusterMethodName(clusterMethod m);

// Helper function to collect members (can be made internal if not needed elsewhere)
void collect_members(int c,
                     int N_pts,
                     const std::vector<int>& left_child,
                     const std::vector<int>& right_child,
                     std::vector<int>& out);


/**
 * Evaluate clustering results against ground truth labels
 * @param true_labels: Ground truth cluster labels from CSV
 * @param predicted_clusters: Clusters generated by single linkage algorithm
 * @param total_points: Total number of data points
 * @return ClusterMetrics structure with various evaluation metrics
 */
ClusterMetrics evaluateClustering(const std::vector<int>& true_labels,
                                const std::vector<std::vector<int>>& predicted_clusters,
                                int total_points);

/**
 * Print clustering evaluation results
 */
void printClusteringEvaluation(const ClusterMetrics& metrics, bool quiet_mode = false);


#endif // SINGLE_LINKAGE_HPP